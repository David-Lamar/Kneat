package kneat.evolution.genome


import kneat.evolution.genome.genes.ConnectionGene
import kneat.evolution.genome.genes.Gene
import kneat.evolution.genome.genes.NodeGene
import kneat.evolution.genome.genes.attributes.Attribute
import kneat.evolution.genome.genes.attributes.BooleanAttribute
import kneat.evolution.genome.genes.attributes.FloatAttribute
import kneat.evolution.genome.genes.configuration.ConnectionConfiguration
import kneat.evolution.genome.genes.configuration.ConnectionType
import kneat.evolution.genome.genes.configuration.NodeConfiguration
import kneat.evolution.network.*
import kneat.evolution.species.SpeciationScheme
import kneat.util.*
import kneat.util.reporting.Reporter
import kotlin.random.Random

/**
 * The genetic makeup of a Neural Network; in other words, the blueprint used to build a Neural Network
 *
 * @property key The unique identifier for the Genome
 * @property config The [GenomeConfiguration] used to specify the behavior of this Genome
 *
 * @param specifiedConnections The initial connections present in this genome; this shouldn't need to be called
 * in normal circumstances and is mostly just a helper for immutable copying. Defaults to an empty list
 * @param specifiedNodes The initial nodes present in this genome; this shouldn't need to be called
 * in normal circumstances and is mostly just a helper for immutable copying. Defaults to an empty list
 * @param specifiedReporters The reporters that wish to be notified of any information provided by the Genome. Defaults
 * to an empty list
 */
open class Genome(
    val key: Long,
    val config: GenomeConfiguration,
    specifiedConnections: MutableList<Connection> = mutableListOf(),
    specifiedNodes: MutableList<Node> = mutableListOf(),
    specifiedReporters: MutableList<Reporter> = mutableListOf() //TODO: This should not be a "specified" item
) {
    /**
     * The unique identifiers for the nodes that will act as inputs to the generated neural network.
     */
    open val inputKeys = (-config.nodeConfiguration.inputs..-1L).toList().reversed()

    /**
     * The unique identifiers for the nodes that will act as outputs to the generated neural network
     */
    open val outputKeys: List<Long> = (1L..config.nodeConfiguration.outputs).toList()

    /**
     * Mutable list of connections managed by this genome; will directly translate to [Connection]s in a
     * neural network
     */
    private var _connections: MutableList<Connection> = specifiedConnections

    /**
     * Publicly available, unmodifiable list of connections present in this genome
     */
    val connections: List<Connection> = _connections

    /**
     * Mutable list of nodes managed by this genome; will directly translate to [Node]s in a
     * neural network
     */
    private var _nodes: MutableList<Node> = specifiedNodes

    /**
     * Publicly available, unmodifiable list of nodes present in this genome
     */
    val nodes: List<Node> = _nodes

    /**
     * The reporters that wish to be notified of any information provided by the Genome. Defaults
     * to an empty list
     */
    private var _reporters: MutableList<Reporter> = specifiedReporters

    /**
     * The list of possible [Activation] functions that this genome may use
     */
    protected var activationList: MutableList<Activation> = mutableListOf(
        *config.activationConfig.available.toTypedArray()
    )

    /**
     * The list of possible [Aggregation] functions that this genome may use
     */
    protected var aggregationList: MutableList<Aggregation> = mutableListOf(
        *config.aggregationConfiguration.available.toTypedArray()
    )

    /**
     * The history of all fitnesses previously generated by this Genome
     */
    private val fitnessHistory: MutableMap<Long, Float> = mutableMapOf()

    init {
        initializeNodes()
        initializeConnections()
    }

    /******* Public Final API *****/

    /**
     * Adds an [Activation] function to this Genome for possible usage
     */
    fun addActivation(activation: Activation) {
        activationList.add(activation)
    }

    /**
     * Adds a [Aggregation] function to this Genome for possible usage
     */
    fun addAggregation(aggregation: Aggregation) {
        aggregationList.add(aggregation)
    }

    /**
     * Adds a reporter to this Genome
     */
    fun addReporter(reporter: Reporter) {
        _reporters.add(reporter)
    }

    /******* Public Open API *****/

    /**
     * Mutates the genome according to the specifications in the [GenomeConfiguration]. There are two primary
     * phases of mutations as follows:
     *
     * ### Structural Mutations
     * 1. Depending on the probability defined in [NodeConfiguration.additionProbability], if
     * probable, a node will be added to the Neural Network. *Note*: If [StructureConfiguration.ensureStructuralMutation]
     * has been specified and there are _no_ connections currently present, a connection will be generated instead of a node.
     * 2.Depending on the probability defined in [NodeConfiguration.deletionProbability], if
     * probable, a randomly selected non-input and non-output node will be deleted.
     * 3. Depending on the probability defined in [ConnectionConfiguration.additionProbability], if
     * probable, a connection will be added to the Neural Network. See [mutateAddConnection] as there is some significant
     * performance implications depending on the [GenomeConfiguration].
     * 4. Depending on how many structural mutations are allowed via [StructureConfiguration.allowedStructuralMutations],
     * we will make the above mutations, in order, until that limit is reached or all mutations have been applied.
     *
     * ### [NetworkElement] Mutations
     * 1. For all [Node]s, [Attribute.mutate] will be called for each [Attribute] managed by the [Node]'s [NodeGene]
     * 2. For all [Connection]s, [Attribute.mutate] will be called for each [Attribute] managed by the [Connection]'s [ConnectionGene]
     *
     * *Note*: [NetworkElement] mutations are *not* limited by
     * [StructureConfiguration.allowedStructuralMutations].
     */
    open fun mutate() {
        val allowedMutations = config.structureConfiguration.allowedStructuralMutations

        if (allowedMutations == 0) {
            //TODO: Should make this an annotation and use a custom annotation processor
            throw IllegalStateException()
        }

        val nodeAddProb = config.nodeConfiguration.additionProbability
        val nodeDelProb = config.nodeConfiguration.deletionProbability
        val connAddProb = config.connectionConfiguration.additionProbability
        val connDelProb = config.connectionConfiguration.deletionProbability

        val rand = Random.nextFloat()

        val mutateList = mutableListOf<() -> Unit>()

        if (rand < nodeAddProb) mutateList.add {
            if (_connections.size == 0 && config.structureConfiguration.ensureStructuralMutation) {
                mutateAddConnection()
            } else {
                mutateAddNode()
            }
        }

        if (rand < nodeDelProb) mutateList.add { mutateDeleteNode() }
        if (rand < connAddProb) mutateList.add { mutateAddConnection() }
        if (rand < connDelProb) mutateList.add { mutateDeleteConnection() }

        mutateList.shuffled().takeLast(allowedMutations).forEach { it() }

        //TODO: May be wise to make a configuration for maximum connection mutations
        _connections.forEach { connection ->
            connection.gene.managedAttributes.values.forEach { gene -> gene.mutate() }
        }

        //TODO: May be wise to make a configuration for maximum node mutations
        _nodes.forEach { node ->
            node.gene.managedAttributes.values.forEach { gene -> gene.mutate() }
        }
    }

    /**
     * Evaluates the genome's fitness based on the [evaluationFunction] and save the fitness for the
     * [generation] provided in [fitnessHistory]
     */
    open suspend fun evaluate(evaluationFunction: EvaluationFunction, generation: Long) : Float {
        val fitness = evaluationFunction(this)
        fitnessHistory[generation] = fitness
        return fitness
    }

    /**
     * Gets the genome's fitness for a specific [generation] or the most recent if [generation] is a negative number.
     */
    open fun getFitness(generation: Long = -1) : Float {
        val key = if (generation < 0) fitnessHistory.keys.maxOfOrNull { it } ?: -1 else generation
        return fitnessHistory.getOrElse(key) { error("Attempted to retrieve fitness history for $key however, $key was not found.") }
    }

    /**
     * Gets the distance between this genome and [other].
     *
     * Distance between two genomes is calculated by adding two values:
     * 1. Taking the [Gene.distance] for each gene in each genome multiplied by the
     * [CompatibilityConfiguration.weightCoefficient] and adding them together; referred to as the gene distance
     * 2. The number of disjoint nodes between the two genomes multiplied by the
     * [CompatibilityConfiguration.disjointCoefficient]; referred to as the disjoint distance
     *
     * ## Calculating Gene Distance
     *
     * Example: You have two genomes;
     * Genome A has gene[1] with a managed FloatAttribute of 1.0, gene[2] with a managed FloatAttribute of 0.8
     * Genome B has gene[1] with a managed FloatAttribute of 1.2, gene[2] with a managed FloatAttribute of 1.0
     *
     * We will check each difference for each gene. So, Genome A, gene[1] has a value of 1.0 and Genome B, gene[1] has
     * a value of 1.2. The absolute difference between these is 0.2. If we look at both gene[2]'s, we see they have the
     * same difference of 0.2.
     *
     * Each of these values would get multiplied by the [CompatibilityConfiguration.weightCoefficient]
     * and then added together, so the total gene distance between these two genomes would be:
     *
     * geneDistance = (0.2 * [CompatibilityConfiguration.weightCoefficient]) + (0.2 * [CompatibilityConfiguration.weightCoefficient])
     *
     * For more information about how this impacts the the genome population, see [SpeciationScheme].
     *
     *
     * ## Calculating Disjoint Distance
     * Example: You have two genomes;
     * Genome A has 1 input node (Node[-1]), 2 hidden nodes (Node[2] and Node[3]), and 1 output node(Node[1]).
     * Genome B has 1 input node (Node[-1]), 1 hidden node (Node[4], NOTE: Has genetically different ancestry from
     * Node[2] and Node[3] above]]), and 1 output node (Node[1]).
     *
     * We would calculate the number of disjoint nodes by seeing which nodes in the network are different; in this case
     * Node[2] and Node[3] are not present in Genome B; similarly, Node[4] is not present in Genome A. All other nodes
     * share similar ancestry.
     *
     * In this example, the number of disjoint nodes is 3; so [CompatibilityConfiguration.disjointCoefficient]
     * would be multiplied by 3, so the total disjoint node distance would be:
     *
     * disjointDistance = 3 * [CompatibilityConfiguration.disjointCoefficient]
     */
    open fun distance(other: Genome) : Float {
        val cacheKey = Pair(this.key, other.key)

        val cacheValue = cachedDistances.getOrDefault(cacheKey, null)

        if (cacheValue != null) {
            cacheHits++
            return cacheValue
        } else {
            cacheMisses++

            val compKey = Pair(other.key, this.key)

            val nodeDistance = _nodes.distance(
                to = other._nodes,
                weightCoefficient = config.compatibilityConfiguration.weightCoefficient,
                disjointCoefficient = config.compatibilityConfiguration.disjointCoefficient
            )

            val connectionDistance = _connections.distance(
                to = other._connections,
                weightCoefficient = config.compatibilityConfiguration.weightCoefficient,
                disjointCoefficient = config.compatibilityConfiguration.disjointCoefficient
            )

            val distance = nodeDistance + connectionDistance
            cachedDistances[cacheKey] = distance
            cachedDistances[compKey] = distance
            return distance
        }
    }

    /**
     * Returns the size of the Genome which is considered the number of enabled connections + number of non-input nodes
     */
    open fun size() : Int {
        val enabledConnections = _connections.count { it.gene.managedAttributes.getAs<BooleanAttribute>(ConnectionGene.ENABLED_GENE).value }
        return _nodes.size + enabledConnections
    }

    /******* Private default implementation for a genome *****/

    /**
     * Creates the initial outputs nodes specified by [NodeConfiguration.outputs] as well as any
     * initial hidden nodes if specified by [NodeConfiguration.initialHidden]
     */
    private fun initializeNodes() {
        // Add output nodes (Note: input nodes not needed since they aren't real "nodes" with activations, etc.
        outputKeys.forEach {
            _nodes.add(createNode(it, config))
        }

        // Add hidden nodes if configured
        for (hidden in 0 until config.nodeConfiguration.initialHidden) {
            _nodes.add(createNode(getNewNodeKey(), config))
        }
    }

    /**
     * Returns a new, unique node identifier not already used by one of the [nodes]
     */
    private fun getNewNodeKey() : Long {
        return _nodes.maxOf { it.id } + 1
    }

    /**
     * Creates the initial connections specified by [ConnectionConfiguration]
     */
    private fun initializeConnections() {
        val allNodes = _nodes.map { it.id }
        val hiddenNodes = allNodes.filter { !outputKeys.contains(it) }
        val initialConnection = config.connectionConfiguration.initialConnection
        val (inputs, outputs) = when(initialConnection) {
            ConnectionType.Unconnected -> {
                listOf(emptyList(), emptyList())
            }
            ConnectionType.SingleSelection.All -> {
                listOf(listOf(inputKeys.random()), allNodes)
            }
            ConnectionType.SingleSelection.HiddenOnly -> {
                listOf(
                    listOf(inputKeys.random()),
                    if (hiddenNodes.isEmpty()) {
                        _reporters.report().warn(
                            WARNING_INITIAL_CONFIGURATION.format(
                                "SingleSelection.HiddenOnly",
                                "SingleSelection.All"
                            ))
                        allNodes
                    } else {
                        hiddenNodes
                    }
                )
            }
            ConnectionType.SingleSelection.OutputOnly -> {
                listOf(listOf(inputKeys.random()), outputKeys)
            }
            is ConnectionType.PartialSelection.All -> {
                listOf(
                    inputKeys.filter { Random.nextFloat() < initialConnection.probability },
                    allNodes
                )
            }
            is ConnectionType.PartialSelection.HiddenOnly -> {
                listOf(
                    inputKeys.filter { Random.nextFloat() < initialConnection.probability },
                    if (hiddenNodes.isEmpty()) {
                        _reporters.report().warn(
                            WARNING_INITIAL_CONFIGURATION.format(
                                "PartialSelection.HiddenOnly",
                                "PartialSelection.All"
                            ))
                        allNodes
                    } else {
                        hiddenNodes
                    }
                )
            }
            is ConnectionType.PartialSelection.OutputOnly -> {
                listOf(
                    inputKeys.filter { Random.nextFloat() < initialConnection.probability },
                    outputKeys
                )
            }
            ConnectionType.FullSelection.All -> {
                listOf(inputKeys, allNodes)
            }
            ConnectionType.FullSelection.HiddenOnly -> {
                listOf(
                    inputKeys,
                    if (hiddenNodes.isEmpty()) {
                        _reporters.report().warn(
                            WARNING_INITIAL_CONFIGURATION.format(
                                "FullSelection.HiddenOnly",
                                "FullSelection.All"
                            ))
                        allNodes
                    } else {
                        hiddenNodes
                    }
                )
            }
            ConnectionType.FullSelection.OutputOnly -> {
                listOf(inputKeys, outputKeys)
            }
        }

        outputs.forEach { output ->
            inputs.forEach { input ->
                _connections.add(createConnection(newKey = Pair(input, output), config = config))
            }
        }
    }

    /**
     * A mutate event that adds a new node to the network. The added node will be put on a randomly selected
     * [connections] item; essentially splitting the connection and maintaining the current behavior until a
     * mutate event changes the node value or connection(s) that feed through it.
     */
    private fun mutateAddNode() {
        val toSplit = _connections.random()
        val toSplitWeight = toSplit.gene.managedAttributes.getAs<FloatAttribute>(ConnectionGene.WEIGHT_GENE).value
        val newNodeId = getNewNodeKey()
        val newNode = createNode(
            nodeId = newNodeId,
            config = config
        )

        _nodes.add(newNode)
        _connections.replaceAll {
            if (it.id == toSplit.id) {
                createConnection(it.id, config = config, enabled = false)
            } else {
                it
            }
        }

        val (input, output) = toSplit.id

        _connections.addAll(
            createConnection(Pair(input, newNodeId), config = config, weight = 1f, enabled = true),
            createConnection(Pair(newNodeId, output), config = config, weight = toSplitWeight, enabled = true)
        )
    }

    /**
     * A mutate event that deletes a randomly selected, non-input and non-output node in the network. All
     * connections that feed into or out of this node will also be removed.
     *
     * TODO: May be a nice improvement if connections are "merged" on deletions. Example:
     *  You have 3 nodes with connections represented as a ->; Node[1] -> Node[2] -> Node[3].
     *  If Node[2] is deleted, and there's no connection between Node[1] and Node[3], the connections
     *  previously used from 1->2 and 2->3 would be combined into a single, 1->3 connection.
     */
    private fun mutateDeleteNode() {
        val deleteList = _nodes.filter { !outputKeys.contains(it.id) }
        if (deleteList.isEmpty()) return

        val deleteNode = deleteList.random()
        _nodes.remove(deleteNode)
        _connections.removeIf {
            it.id.first == deleteNode.id || it.id.second == deleteNode.id
        }
    }

    /**
     * Gets an input id for the specified [toOutputId] that ensures:
     * 1. If [toOutputId] is an output node, we will NOT connect to another output node
     * 2. If [ConnectionConfiguration.allowRecurrence] is set to false, the selected
     * input *must not* cause loops in the network.
     *
     * If any of these conditions fails, null will be returned
     *
     * ### Performance Concerns
     *
     * This method will potentially be called multiple times if a sufficient input id cannot be discovered.
     * This is exacerbated by [ConnectionConfiguration.allowRecurrence] if set to false,
     * because we need to check to ensure that there are no loops caused by the potential connection. Checking for
     * loops is _very expensive_; especially if the network is large. Due to the asynchronous nature of a Kneat
     * [Network], there is negligible penalty to having recurrence in a
     * network. If you don't _absolutely_ need a Feed-Forward network, it is advised that you keep
     * [ConnectionConfiguration.allowRecurrence] allowed.
     */
    private fun getInputId(toOutputId: Long) : Long? { //TODO: Expensive operations -- Parallelize
        var inputList = (_nodes.map { it.id } + inputKeys)

        val outputIsTerminal = outputKeys.contains(toOutputId)

        // If our output is an output key, we don't a connection going to another output
        if (outputIsTerminal) inputList = inputList.filter { !outputKeys.contains(it) }

        if (!config.connectionConfiguration.allowRecurrence && !outputIsTerminal) {
            _reporters.report().info("Calculating connection and ensuring loop safety... (If a feed-forward network isn't necessary, you can speed this up by allowing recurrence.)")

            // We want to remove ALL nodes that output could possibly go INTO. Make sure we don't have loops
            val relatedNodes = mutableListOf<Long>()
            var checkList = listOf(toOutputId)

            while (checkList.isNotEmpty()) {
                val nextCheck = mutableListOf<Long>()

                checkList.forEach { checkId ->
                    if (!relatedNodes.contains(checkId)) relatedNodes.add(checkId)

                    nextCheck.addAll(
                        _connections
                            .filter { it.id.first == checkId
                                    && !relatedNodes.contains(it.id.second)
                                    && !nextCheck.contains(it.id.second) }
                            .map { it.id.second }
                    )
                }

                checkList = nextCheck
            }

            inputList = inputList.filter { relatedNodes.contains(it) }
        }

        return if (inputList.isEmpty()) null else inputList.random()
    }

    /**
     * A mutate event that adds a new connection to a randomly selected output from a randomly selected
     * input with the conditions specified in [getInputId].
     *
     * If [StructureConfiguration.ensureStructuralMutation] is set, and the connection
     * to be added is already present in the network, it will instead be enabled.
     *
     * TODO: If the found connection is already enabled, should we disable it for ensuring structural mutation?
     */
    private fun mutateAddConnection() { //TODO: Expensive operations -- Parallelize
        val ensureStructuralMutation = config.structureConfiguration.ensureStructuralMutation

        val availableOutputList = _nodes.map { it.id }.toMutableList()
        var outputId: Long
        var existingConnectionEnabled : Boolean? = null
        var newId: Pair<Long, Long>? = null

        // Guarantee a connection is found based on our config criteria
        do {
            outputId = availableOutputList.random()
            availableOutputList.remove(outputId) // Narrow our potential search for next time, if needed

            getInputId(outputId)?.let { inputId ->
                newId = Pair(inputId, outputId)
                val existingConnection = _connections.find { it.id == newId}
                existingConnectionEnabled = existingConnection
                    ?.gene
                    ?.managedAttributes
                    ?.getAs<BooleanAttribute>(ConnectionGene.ENABLED_GENE)
                    ?.value
            }
        } while (newId == null || (ensureStructuralMutation && existingConnectionEnabled == true))

        val finalizedId = newId ?: return

        if (ensureStructuralMutation && existingConnectionEnabled == false) {
            ensureStableStructure(finalizedId)
            return // We've made a "mutation" by enabling a connection, so we can exit
        }

        _connections.add(createConnection(finalizedId, config))
    }

    /**
     * Used in [mutateAddConnection], ensures that if a potential connection already exists in the network,
     * it is instead enabled
     */
    private fun ensureStableStructure(newId: Pair<Long, Long>) : Boolean {
        var foundMatch = false
        _connections.replaceAll {
            if (it.id == newId) {
                foundMatch = true
                createConnection(it.id, enabled = true, config = config)
            } else {
                it
            }
        }

        return foundMatch
    }

    /**
     * A mutate event that removes a random connection from the network
     */
    private fun mutateDeleteConnection() {
        _connections.removeRandom()
    }

    companion object {
        /**
         * Distances between two genomes can be calculated multiple times for the same two genomes during
         * different stages of the NEAT algorithm. Since executing the [distance] method is fairly expensive,
         * caching distances between genomes allows us to pull from the cache instead of recalculating distance each time
         * a duplicate call is made to [distance].
         */
        private var cachedDistances: MutableMap<Pair<Long, Long>, Float> = mutableMapOf()

        /**
         * Meta data about the cache for us to know how many "hits" or successful cache accesses we're seeing throughout execution
         */
        private var cacheHits: Long = 0

        /**
         * Meta data about the cache for us to know how many "misses" or times where the cache does not have a value
         * present we're seeing throughout execution
         */
        private var cacheMisses: Long = 0

        /**
         * Creates a new [Genome] with the specified [newId] via a "crossover" of the two parent genomes.
         *
         * > Crossover: _is the exchange of genetic information during reproduction between two individuals resulting in a new recombinant of genetic information._
         */
        suspend fun createFromCrossover(
            newId: Long,
            first: Genome,
            other: Genome,
        ) : Genome {
            val (parent1, parent2) = listOf(first, other).sortedBy { it.getFitness() }

            val newConnections = parent1._connections.mapParallel { p1c ->
                val p2Connect = parent2._connections.find { p2c -> p2c.id == p1c.id }

                if (p2Connect == null) {
                    p1c
                } else {
                    val newGene = p1c.gene.crossover(p1c.gene)
                    Connection(p1c.id, newGene as ConnectionGene)
                }
            }

            val newNodes = parent1._nodes.mapParallel { p1n ->
                val p2Node = parent2._nodes.find { p2c -> p2c.id == p1n.id }

                if (p2Node == null) {
                    p1n
                } else {
                    val newGene = p1n.gene.crossover(p2Node.gene)
                    Node(p1n.id, newGene as NodeGene)
                }
            }

            return Genome(
                key = newId,
                config = parent1.config,
                specifiedConnections = newConnections.toMutableList(),
                specifiedNodes = newNodes.toMutableList(),
                specifiedReporters = parent1._reporters
            )
        }

        /**
         * Helper function to create a new node with the specified [nodeId] and [config]
         */
        fun createNode(
           nodeId: Long,
           config: GenomeConfiguration
        ) : Node {
           val gene = NodeGene(
               config.biasConfiguration,
               config.responseConfiguration,
               config.activationConfig,
               config.aggregationConfiguration
           )
            return Node(nodeId, gene)
        }

        /**
         * Helper function to create a new connection with the specified [newKey], [config] and optional
         * values for [weight] and the [enabled] state of the connection.
         */
        fun createConnection(
            newKey: Pair<Long, Long>,
            config: GenomeConfiguration,
            weight: Float? = null,
            enabled: Boolean? = null
        ) : Connection {
            val gene = ConnectionGene(
                config.weightConfiguration.copy(default = weight ?: config.weightConfiguration.default),
                config.connectionConfiguration.copy(default = enabled ?: config.connectionConfiguration.default)
            )

            return Connection(newKey, gene)
        }
    }
}