package kneat.evolution.genome

import kneat.evolution.genome.configuration.GenomeConfiguration
import kneat.evolution.genome.genes.ConnectionGene
import kneat.evolution.genome.genes.Gene
import kneat.evolution.genome.genes.NodeGene
import kneat.evolution.genome.genes.attributes.Attribute
import kneat.evolution.genome.genes.configuration.ConnectionConfiguration
import kneat.evolution.genome.genes.configuration.NodeConfiguration
import kneat.evolution.network.*
import kneat.evolution.species.SpeciationScheme
import kneat.util.reporting.Reporter


//TODO: Need to finish this so it's not wonky
abstract class Genome(
    val id: Long,
    val config: GenomeConfiguration,
    specifiedReporters: MutableList<Reporter> = mutableListOf()
) {
    /**
     * The unique identifiers for the nodes that will act as inputs to the generated neural network.
     */
    open val inputKeys = (-config.nodeConfiguration.inputs..-1L).toList().reversed()

    /**
     * The unique identifiers for the nodes that will act as outputs to the generated neural network
     */
    open val outputKeys: List<Long> = (1L..config.nodeConfiguration.outputs).toList()

    /**
     * Mutable list of connections managed by this genome; will directly translate to [Connection]s in a
     * neural network
     */
    //protected open var _connections: MutableList<Connection> = mutableListOf()

    /**
     * Publicly available, unmodifiable list of connections present in this genome
     */
    abstract val connections: List<Connection>

    /**
     * Mutable list of nodes managed by this genome; will directly translate to [Node]s in a
     * neural network
     */
    //protected open var _nodes: MutableList<Node> = mutableListOf()

    /**
     * Publicly available, unmodifiable list of nodes present in this genome
     */
    abstract val nodes: List<Node>

    /**
     * The reporters that wish to be notified of any information provided by the Genome. Defaults
     * to an empty list
     */
    //protected open var _reporters: MutableList<Reporter> = specifiedReporters

    abstract val reporters: List<Reporter>

    /**
     * The list of possible [Activation] functions that this genome may use
     */
    protected open var activationList: MutableList<Activation> = mutableListOf(
        *config.activationConfig.available.toTypedArray()
    )

    /**
     * The list of possible [Aggregation] functions that this genome may use
     */
    protected open var aggregationList: MutableList<Aggregation> = mutableListOf(
        *config.aggregationConfiguration.available.toTypedArray()
    )

    /**
     * The history of all fitnesses previously generated by this Genome
     */
    protected open val fitnessHistory: MutableMap<Long, Float> = mutableMapOf()

//    /**
//     * Adds an [Activation] function to this Genome for possible usage
//     */
//    fun addActivation(activation: Activation) {
//        activationList.add(activation)
//    }
//
//    /**
//     * Adds a [Aggregation] function to this Genome for possible usage
//     */
//    fun addAggregation(aggregation: Aggregation) {
//        aggregationList.add(aggregation)
//    }
//
//    /**
//     * Adds a reporter to this Genome
//     */
//    fun addReporter(reporter: Reporter) {
//        _reporters.add(reporter)
//    }

    /**
     * Mutates the genome according to the specifications in the [GenomeConfiguration]. There are two primary
     * phases of mutations as follows:
     *
     * ### Structural Mutations
     * 1. Depending on the probability defined in [NodeConfiguration.additionProbability], if
     * probable, a node will be added to the Neural Network. *Note*: If [StructureConfiguration.ensureStructuralMutation]
     * has been specified and there are _no_ connections currently present, a connection will be generated instead of a node.
     * 2.Depending on the probability defined in [NodeConfiguration.deletionProbability], if
     * probable, a randomly selected non-input and non-output node will be deleted.
     * 3. Depending on the probability defined in [ConnectionConfiguration.additionProbability], if
     * probable, a connection will be added to the Neural Network. See [mutateAddConnection] as there is some significant
     * performance implications depending on the [GenomeConfiguration].
     * 4. Depending on how many structural mutations are allowed via [StructureConfiguration.allowedStructuralMutations],
     * we will make the above mutations, in order, until that limit is reached or all mutations have been applied.
     *
     * ### [NetworkElement] Mutations
     * 1. For all [Node]s, [Attribute.mutate] will be called for each [Attribute] managed by the [Node]'s [NodeGene]
     * 2. For all [Connection]s, [Attribute.mutate] will be called for each [Attribute] managed by the [Connection]'s [ConnectionGene]
     *
     * *Note*: [NetworkElement] mutations are *not* limited by
     * [StructureConfiguration.allowedStructuralMutations].
     */
    abstract fun mutate()

    /**
     * Evaluates the genome's fitness based on the [evaluationFunction] and save the fitness for the
     * [generation] provided in [fitnessHistory]
     */
    abstract suspend fun evaluate(evaluationFunction: EvaluationFunction, generation: Long): Float

    /**
     * Gets the genome's fitness for a specific [generation] or the most recent if [generation] is a negative number.
     */
    abstract fun getFitness(generation: Long = -1) : Float

    /**
     * Gets the distance between this genome and [other].
     *
     * Distance between two genomes is calculated by adding two values:
     * 1. Taking the [Gene.distance] for each gene in each genome multiplied by the
     * [CompatibilityConfiguration.weightCoefficient] and adding them together; referred to as the gene distance
     * 2. The number of disjoint nodes between the two genomes multiplied by the
     * [CompatibilityConfiguration.disjointCoefficient]; referred to as the disjoint distance
     *
     * ## Calculating Gene Distance
     *
     * Example: You have two genomes;
     * Genome A has gene[1] with a managed FloatAttribute of 1.0, gene[2] with a managed FloatAttribute of 0.8
     * Genome B has gene[1] with a managed FloatAttribute of 1.2, gene[2] with a managed FloatAttribute of 1.0
     *
     * We will check each difference for each gene. So, Genome A, gene[1] has a value of 1.0 and Genome B, gene[1] has
     * a value of 1.2. The absolute difference between these is 0.2. If we look at both gene[2]'s, we see they have the
     * same difference of 0.2.
     *
     * Each of these values would get multiplied by the [CompatibilityConfiguration.weightCoefficient]
     * and then added together, so the total gene distance between these two genomes would be:
     *
     * geneDistance = (0.2 * [CompatibilityConfiguration.weightCoefficient]) + (0.2 * [CompatibilityConfiguration.weightCoefficient])
     *
     * For more information about how this impacts the the genome population, see [SpeciationScheme].
     *
     *
     * ## Calculating Disjoint Distance
     * Example: You have two genomes;
     * Genome A has 1 input node (Node[-1]), 2 hidden nodes (Node[2] and Node[3]), and 1 output node(Node[1]).
     * Genome B has 1 input node (Node[-1]), 1 hidden node (Node[4], NOTE: Has genetically different ancestry from
     * Node[2] and Node[3] above]]), and 1 output node (Node[1]).
     *
     * We would calculate the number of disjoint nodes by seeing which nodes in the network are different; in this case
     * Node[2] and Node[3] are not present in Genome B; similarly, Node[4] is not present in Genome A. All other nodes
     * share similar ancestry.
     *
     * In this example, the number of disjoint nodes is 3; so [CompatibilityConfiguration.disjointCoefficient]
     * would be multiplied by 3, so the total disjoint node distance would be:
     *
     * disjointDistance = 3 * [CompatibilityConfiguration.disjointCoefficient]
     */
    abstract fun distance(other: Genome) : Float

    /**
     * Returns the size of the Genome which is considered the number of enabled connections + number of non-input nodes
     */
    abstract fun size() : Int
}